weighted_mean_sd <- function(x, weights=rep(1,nrow(x))){
weights <- weights/sum(weights)
# xm <- drop(t(weights)%*%x)
xm <- t(weights)%*%x
# xv <- drop(t(weights)%*%scale(x,xm,FALSE)^2)
xv <- t(weights)%*%scale(x,xm,FALSE)^2
xv[abs(xv) < 10*.Machine$double.eps] <- 0
# xv[xv < 10*.Machine$double.eps] <- 0
list(mean = xm, sd = sqrt(xv))
}
#' fit a complex-valued lasso
#'
#' Fit a complex-valued lasso formulation via complex update coordinate descent algorithm.
#' By defining a field isomophism between complex values and its 2 by 2 representation,
#' it enables to update each coordinate of the solution as a regular coordinate descent algorithm.
#'
#' The sequence of models implied by \code{lambda} is fit by coordinate descent.
#' For \code{family="gaussian"} this is the lasso sequence.
#'
#' @param x input matrix, of dimension nobs x nvars; each row is an observation vector.
#' Requirement: \code{nvars >1}; in other words, \code{x} should have 2 or more columns.
#' @param y response variable.
#' @param family To match the conventional functions used in \code{glmnet}, "gaussian" is assumed. This has to be eliminated.
#' @param weights observation weights. Default is 1 for each observation.
#' @param nlambda The number of \code{lambda} values - default is 100.
#' @param lambda.min.ratio Smallest value for \code{lambda}, as a fraction of
#' \code{lambda.max}, the (data derived) entry value (i.e. the smallest value
#' for which all coefficients are zero). The default depends on the sample size
#' \code{nobs} relative to the number of variables \code{nvars}.
#' If \code{nobs > nvars}, the default is \code{0.0001}, close to zero.
#' If \code{nobs < nvars}, the default is \code{0.01}.
#' A very small value of \code{lambda.min.ratio} will lead to a saturated fit
#' in the \code{nobs < nvars} case.
#' @param lambda A user supplied \code{lambda} sequence.
#' Typical usage is to have the program compute its own \code{lambda} sequence based on
#' \code{nlambda} and \code{lambda.min.ratio}.
#' Supplying a value of \code{lambda} overrides this.
#' WARNING: use with care. Avoid supplying a single value for \code{lambda}
#' (for predictions after CV use \code{predict()} instead).
#' Supply instead a decreasing sequence of \code{lambda} values.
#' \code{classo} relies on its warms starts for speed, and its often faster to fit a whole path than compute a single fit.
#' @param standardize Logical flag for x variable standardization, prior to
#' fitting the model sequence. The coefficients are always returned on the
#' original scale. Default is \code{standardize=FALSE}.
#' @param intercept Should intercept(s) set to zero (default=FALSE) or be fitted (TRUE).
#' @param thresh Convergence threshold for coordinate descent.
#' Each inner coordinate-descent loop continues until the maximum change in the objective
#' after any coefficient update is less than \code{thresh} times the null
#' deviance. Defaults value is \code{1E-7}.
#' @param trace.it If \code{trace.it=1}, then a progress bar is displayed;
#' useful for big models that take a long time to fit.
#'
#' @author Navonil Deb, Younghoon Kim, Sumanta Basu \cr Maintainer: Younghoon Kim
#' \email{yk748@cornell.edu}
#' @references Deb, N., Kuceyeski, A., Basu, S. (2024)
#' \emph{Regularized Estimation of Sparse Spectral Precision Matrices},
#' \url{https://arxiv.org/abs/2401.11128}.
#' @keywords models complex-valued regression
#'
#' @examples
#'
#' example <- classo(x, y, lambda, weights, b.init)
# n = 1000
# p = 200
# x = array(rnorm(n*p), c(n,p)) + (1+1i) * array(rnorm(n*p), c(n,p))
# for (j in 1:p) x[,j] = x[,j] / sqrt(mean(Mod(x[,j])^2))
# e = rnorm(n) + (1+1i) * rnorm(n)
# b = c(1, -1, rep(0, p-2)) + (1+1i) * c(-0.5, 2, rep(0, p-2))
# y = x %*% b + e
#' fit = classo(x, y)
#'
#' @export classo
classo <- function(x,y,
weights=NULL,
family=gaussian(),
lambda=NULL,
nlambda=100,
lambda.min.ratio=ifelse(nobs<nvars,1e-2,1e-4),
standardized=FALSE,
intercept=FALSE,
maxit=100000,
trace.it=0,...){
# ------------------------------------------------ #
# x, # included
# y, # included
# family="gaussian", # included
# weights=NULL, # included
# offset=NULL, # deleted
# alpha=1.0, # deleted
# nlambda=100, # included
# lambda.min.ratio=ifelse(nobs<nvars,1e-2,1e-4), # included
# lambda=NULL, # included
# standardize=TRUE, # included
# intercept=FALSE, # included
# thresh=1e-7, # included
# dfmax=nvars+1, # deleted
# pmax=min(dfmax*2+20,nvars), # deleted
# exclude=NULL, # deleted
# penalty.factor=rep(1,nvars), # deleted
# lower.limits=-Inf, # deleted
# upper.limits=Inf, # deleted
# maxit=100000, # included
# type.gaussian=ifelse(nvars<500,"covariance","naive"), # deleted
# type.logistic=c("Newton","modified.Newton"), # deleted
# standardize.response=FALSE, # deleted
# type.multinomial=c("ungrouped","grouped"), # deleted
# relax=FALSE, # deleted
# trace.it=0 # included
# ------------------------------------------------ #
# YK: gaussian() and related functions should be replaced.
this.call <- match.call()
# ------------------------------------------------ #
# Need to do this first so defaults in call can be satisfied
np <- dim(x)
# check dims
if(is.null(np)|(np[2]<=1)){
stop("x should be a matrix with 2 or more columns")
}
nobs <- np[1]
nvars <- np[2]
# check for NAs in x
if(any(is.na(x))){
stop("x has missing values; consider using makeX() to impute them")
}
# check for NAs in weights
if(is.null(weights)){
weights <- rep(1,nobs)
}else if(length(weights)!=nobs){
stop(paste("number of elements in weights (",length(weights),")
not equal to the number of rows of x (",nobs,")",sep=""))
}
# ------------------------------------------------ #
# See whether its a call to glmnet or to glmnet.path, based on family arg
# note: we exclude the rest of condition checking steps.
# note: here we have only one type of family.
fit <- classo.path(x,y,family = gaussian(),
weights=NULL,
standardized=FALSE,
lambda=NULL,
nlambda=100,
lambda.min.ratio=ifelse(nobs<nvars,1e-2,1e-4),
intercept = FALSE,
thresh = 1e-10,
maxit = 100000,
trace.it = 0)
fit$call <- this.call
fit
}
dyn.load("D:/High-dimensional time series/SSPM/cglasso/src/classocd_warm.dll")
n = 1000
p = 200
x = array(rnorm(n*p), c(n,p)) + (1+1i) * array(rnorm(n*p), c(n,p))
for (j in 1:p) x[,j] = x[,j] / sqrt(mean(Mod(x[,j])^2))
e = rnorm(n) + (1+1i) * rnorm(n)
b = c(1, -1, rep(0, p-2)) + (1+1i) * c(-0.5, 2, rep(0, p-2))
y = x %*% b + e
weights=NULL;
lambda = NULL;
type.measure = "mse";
nfolds = 10;
foldid=NULL;
alignment="lambda";
keep = FALSE;
parallel = FALSE;
trace.it=0
cv.classo(x,y)
cv.test = cv.classo(x,y)
#' plot the cross-validation curve produced by cv.classo
#'
#' Plots the cross-validation curve, and upper and lower standard deviation
#' curves, as a function of the \code{lambda} values used.
#'
#' A plot is produced, and nothing is returned.
#'
#' @aliases plot.cv.classo
#' @param x fitted \code{"cv.classo"} object
#' @param sign.lambda Either plot against \code{log(lambda)} (default) or its
#' negative if \code{sign.lambda=-1}.
#' @param \dots Other graphical parameters to plot
#' @author Jerome Friedman, Trevor Hastie and Rob Tibshirani\cr Maintainer:
#' Trevor Hastie <hastie@@stanford.edu>
#' @seealso \code{classo} and \code{cv.classo}.
#' @author Navonil Deb, Younghoon Kim, Sumanta Basu \cr Maintainer: Younghoon Kim
#' \email{yk748@cornell.edu}
#' @examples
#'
#' set.seed(1010)
#' n = 1000
#' p = 100
#' nzc = trunc(p/10)
#' x = matrix(rnorm(n * p), n, p)
#' beta = rnorm(nzc)
#' fx = (x[, seq(nzc)] %*% beta)
#' eps = rnorm(n) * 5
#' y = drop(fx + eps)
#' px = exp(fx)
#' px = px/(1 + px)
#' ly = rbinom(n = length(px), prob = px, size = 1)
#' cvob1 = cv.glmnet(x, y)
#' plot(cvob1)
#' title("Gaussian Family", line = 2.5)
#' cvob1r = cv.glmnet(x, y, relax = TRUE)
#' plot(cvob1r)
#' frame()
#' set.seed(1011)
#' par(mfrow = c(2, 2), mar = c(4.5, 4.5, 4, 1))
#' cvob2 = cv.glmnet(x, ly, family = "binomial")
#' plot(cvob2)
#' title("Binomial Family", line = 2.5)
#' ## set.seed(1011)
#' ## cvob3 = cv.glmnet(x, ly, family = "binomial", type = "class")
#' ## plot(cvob3)
#' ## title("Binomial Family", line = 2.5)
#'
#' @method plot cv.classo
#' @export
#'
plot.cv.classo <- function(x,sign.lambda=1,...){
# cvobj <- cv_result
cvobj <- x
xlab <- expression(Log(lambda))
#  xlab="log(Lambda)"
if(sign.lambda<0){
xlab <- paste("-",xlab,sep="")
}
plot.args <- list(x=sign.lambda*log(cvobj$lambda),
y=cvobj$cvm,ylim=range(cvobj$cvup,cvobj$cvlo),xlab=xlab,ylab=cvobj$name,type="n")
# new.args <- list(...)
# if(length(new.args)){
#   plot.args[names(new.args)]<-new.args
# }
# ------------------------------------------------ #
do.call("plot",plot.args)
error.bars(sign.lambda*log(cvobj$lambda),cvobj$cvup,cvobj$cvlo,width=0.01,
col="darkgrey")
points(sign.lambda*log(cvobj$lambda),cvobj$cvm,pch=20,col="red")
# axis(side=3,at=sign.lambda*log(cvobj$lambda),labels=paste(cvobj$nz),tick=FALSE,line=0)
abline(v=sign.lambda*log(cvobj$lambda.min),lty=3)
abline(v=sign.lambda*log(cvobj$lambda.1se),lty=3)
invisible()
}
error.bars <- function(x, upper, lower, width = 0.02, ...) {
xlim <- range(x)
barw <- diff(xlim) * width
segments(x, upper, x, lower, ...)
segments(x - barw, upper, x + barw, upper, ...)
segments(x - barw, lower, x + barw, lower, ...)
range(upper, lower)
}
#' plot coefficients from a "classo" object
#'
#' Produces a coefficient profile plot of the coefficient paths for a fitted
#' \code{"classo"} object.
#'
#' A coefficient profile plot is produced. If \code{x} is a multinomial model,
#' a coefficient plot is produced for each class.
#'
#' @aliases plot.classo
#' @param x fitted \code{"classo"} model
#' @param xvar What is on the X-axis. \code{"norm"} plots against the L1-norm
#' of the coefficients, \code{"lambda"} against the log-lambda sequence, and
#' \code{"dev"} against the percent deviance explained.
#' @param label If \code{TRUE}, label the curves with variable sequence
#' numbers.
#' @param \dots Other graphical parameters to plot
#' @author Navonil Deb, Younghoon Kim, Sumanta Basu \cr Maintainer: Younghoon Kim
#' \email{yk748@cornell.edu}
#' @seealso \code{classo}
#'
#' @examples
#' x=matrix(rnorm(100*20),100,20)
#' y=rnorm(100)
#' g2=sample(1:2,100,replace=TRUE)
#' g4=sample(1:4,100,replace=TRUE)
#' fit1=glmnet(x,y)
#' plot(fit1)
#' plot(fit1,xvar="lambda",label=TRUE)
#' fit3=glmnet(x,g4,family="multinomial")
#' plot(fit3,pch=19)
#'
#' @method plot classo
#' @export
plot.glmnet <- function(x, xvar=c("norm","lambda","dev"),label=FALSE,...){
xvar <- match.arg(xvar)
plotCoef(x$beta,lambda=x$lambda,df=x$df,dev=x$dev.ratio,label=label,xvar=xvar,...)
}
plot.cv.classo(cv.test)
fit.test
fit.test = classo(x, y)
#' g2=sample(1:2,100,replace=TRUE)
#' g4=sample(1:4,100,replace=TRUE)
#' fit1=glmnet(x,y)
#' plot(fit1)
#' plot(fit1,xvar="lambda",label=TRUE)
#' fit3=glmnet(x,g4,family="multinomial")
#' plot(fit3,pch=19)
#'
#' @method plot classo
#' @export
plot.classo <- function(x, xvar=c("norm","lambda","dev"),label=FALSE,...){
plot.classo <- function(x, xvar=c("norm","lambda","dev"),label=FALSE,...){
xvar <- match.arg(xvar)
plotCoef(x$beta,lambda=x$lambda,df=x$df,dev=x$dev.ratio,label=label,xvar=xvar,...)
}
beta = fit.test$beta
##beta should be in "dgCMatrix" format
which <- nonzeroCoef(beta)
?approx
install.packages("roxygen2")
install.packages("devtools")
roxygenise()
library(roxygen2); # Read in the roxygen2 R package
roxygenise();
getwd()
setwd("D:/High-dimensional time series/SSPM")
package.skeleton(name="cglasso")
library(devtools)
library(roxygen2)
package.skeleton(name="cglasso")
package.skeleton("cglasso")
devtools::create("cglasso")
library(roxygen2)
roxygenise()
getwd()
setwd("D:/High-dimensional time series/SSPM/R")
setwd("D:/High-dimensional time series/SSPM/cglasso")
roxygenise()
?use_decription()
devtools::create("cglasso")
setwd("D:/High-dimensional time series/SSPM")
devtools::create("cglasso")
roxygenise()
setwd("D:/High-dimensional time series/SSPM/cglasso/R")
roxygenise()
library(roxygen2);
roxygenise();
setwd("D:/High-dimensional time series/SSPM/cglasso")
roxygenise();
?use_description
getOption("usethis.description")
setwd("D:/High-dimensional time series/SSPM")
devtools::create("cglasso")
setwd("D:/High-dimensional time series/SSPM/cglasso")
options(
usethis.description = list(
"Authors@R" = utils::person(
"Jane", "Doe",
email = "jane@example.com",
role = c("aut", "cre"),
comment = c(ORCID = "YOUR-ORCID-ID")
),
"Authors@R" = utils::person(
"Jane", "Doe",
email = "jane@example.com",
role = c("aut", "cre"),
comment = c(ORCID = "YOUR-ORCID-ID")
),
"Authors@R" = utils::person(
"Jane", "Doe",
email = "jane@example.com",
role = c("aut", "cre"),
comment = c(ORCID = "YOUR-ORCID-ID")
),
Description = "This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
Title = "Exact coordinate descent algorithm for complex-valued Lasso"
Language =  "es",
options(
usethis.description = list(
"Authors@R" = utils::person(
"Jane", "Doe",
email = "jane@example.com",
role = c("aut", "cre"),
comment = c(ORCID = "YOUR-ORCID-ID")
),
"Authors@R" = utils::person(
"Jane", "Doe",
email = "jane@example.com",
role = c("aut", "cre"),
comment = c(ORCID = "YOUR-ORCID-ID")
),
"Authors@R" = utils::person(
"Jane", "Doe",
email = "jane@example.com",
role = c("aut", "cre"),
comment = c(ORCID = "YOUR-ORCID-ID")
),
Description = "This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
Title = "Exact coordinate descent algorithm for complex-valued Lasso",
Language =  "es",
License = "MIT + file LICENSE"
)
)
use_description(check_name = TRUE, roxygen = TRUE)
options(
usethis.description = list(
"Authors@R" = utils::person(
"Jane1", "Doe2",
email = "jane@example.com",
role = c("aut", "cre"),
comment = c(ORCID = "YOUR-ORCID-ID")
), utils::person(
"Jane2", "Doe2",
email = "jane@example.com",
role = c("aut", "cre"),
comment = c(ORCID = "YOUR-ORCID-ID")
),
Description = "This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
Title = "Exact coordinate descent algorithm for complex-valued Lasso"
Language =  "es",
options(
usethis.description = list(
"Authors@R" = utils::person(
"Jane1", "Doe2",
email = "jane@example.com",
role = c("aut", "cre"),
comment = c(ORCID = "YOUR-ORCID-ID")
), utils::person(
"Jane2", "Doe2",
email = "jane@example.com",
role = c("aut", "cre"),
comment = c(ORCID = "YOUR-ORCID-ID")
),
Description = "This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
Title = "Exact coordinate descent algorithm for complex-valued Lasso"
Language =  "es",
options(
usethis.description = list(
"Authors@R" = utils::person(
"Jane1", "Doe2",
email = "jane@example.com",
role = c("aut", "cre"),
comment = c(ORCID = "YOUR-ORCID-ID")
), utils::person(
"Jane2", "Doe2",
email = "jane@example.com",
role = c("aut", "cre"),
comment = c(ORCID = "YOUR-ORCID-ID")
),
Description = "This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
Title = "Exact coordinate descent algorithm for complex-valued Lasso",
Language =  "es",
License = "MIT + file LICENSE"
)
)
use_description(check_name = TRUE, roxygen = TRUE)
options(
usethis.description = list(
"Authors@R" = person("Younghoon", "Kim", email = "yk748@cornell.edu", role = c("aut", "cre"), comment = c(ORCID = "0009-0007-0117-5530")),
Description = "This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
Title = "Exact coordinate descent algorithm for complex-valued Lasso",
Language =  "es",
License = "MIT + file LICENSE"
)
)
use_description(check_name = TRUE, roxygen = TRUE)
options(
usethis.description = list(
"Authors@R" = c(person("Younghoon", "Kim", email = "yk748@cornell.edu", role = c("aut", "cre"), comment = c(ORCID = "0009-0007-0117-5530")),person("Navonil", "Deb", email = "nd329@cornell.edu", role = "aut"),
person("Sumanta", "Basu", email = "sumbose@cornell.edu", role = "aut")),
Description = "This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
Title = "Exact coordinate descent algorithm for complex-valued Lasso",
Language =  "es",
License = "MIT + file LICENSE"
)
)
use_description(check_name = TRUE, roxygen = TRUE)
setwd("D:/High-dimensional time series/SSPM/cglasso/R")
roxygenise();
setwd("D:/High-dimensional time series/SSPM/cglasso")
roxygenise();
?useDynLib
useDynLib
options(
usethis.description = list(
"Authors@R" = c(person("Younghoon", "Kim", email = "yk748@cornell.edu", role = c("aut", "cre"), comment = c(ORCID = "0009-0007-0117-5530")),person("Navonil", "Deb", email = "nd329@cornell.edu", role = "aut"),
person("Sumanta", "Basu", email = "sumbose@cornell.edu", role = "aut")),
Description = "This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
Title = "Exact coordinate descent algorithm for complex-valued Lasso",
Language =  "es",
License = "MIT + file LICENSE",
NeedsCompilation: yes
)
)
options(
usethis.description = list(
"Authors@R" = c(person("Younghoon", "Kim", email = "yk748@cornell.edu", role = c("aut", "cre"), comment = c(ORCID = "0009-0007-0117-5530")),person("Navonil", "Deb", email = "nd329@cornell.edu", role = "aut"),
person("Sumanta", "Basu", email = "sumbose@cornell.edu", role = "aut")),
Description = "This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
Title = "Exact coordinate descent algorithm for complex-valued Lasso",
Language =  "es",
License = "MIT + file LICENSE",
NeedsCompilation = "yes"
)
)
use_description(check_name = TRUE, roxygen = TRUE)
use_description(check_name = TRUE, roxygen = TRUE)
roxygenise();
roxygenise();
getNativeSymbolInfo("classo_warm_f", PACKAGE = "cglasso")
roxygenise();
?getLoadedDLLS
getLoadedDLLS()
getLoadedDLLs()
?getLoadedDLLs()
devtools::document()
roxygenise();
useDynLib(cglasso, classo_warm_f)
roxygenise();
roxygenise();
devtools::document()
use_description(check_name = TRUE, roxygen = TRUE)
roxygenise();
