if(is.null(np) || (np[2] <= 1)) {
stop("x should be a matrix with 2 or more columns")
}
nobs <- np[1]
# Unlike glmnet, we treat the intercept term by merging them into the design matrix
# and treat it p+1-dimensional object.
if (intercept){
x <- cbind(rep(1,nobs),x)
nvars <- np[2] + 1
}else{
nvars <- np[2]
}
# ------------------------------------------------ #
# get feature variable names
vnames <- colnames(x)
if(is.null(vnames)){
vnames <- paste("V",seq(nvars),sep="")
}
# ------------------------------------------------ #
# check weights
if(is.null(weights)) {
weights <- rep(1,nobs)
}else if (length(weights) != nobs){
stop(paste("Number of elements in weights (",length(weights),
") not equal to the number of rows of x (",nobs,")",sep=""))
}
weights <- as.double(weights)
# ------------------------------------------------ #
# standardize x if necessary
if (intercept) {
# YK: do we need this?
# Compute weighted mean and variance of columns of x
# needed to detect constant columns below, and later if standarization
meansd <- weighted_mean_sd(x, weights)
xm <- meansd$mean
} else {
xm <- rep(0.0, times = nvars)
}
if (standardized) {
for (j in 1:nvars){
x[,j] <- x[,j] / sqrt(mean(Mod(x[,j])^2))
}
}
# ------------------------------------------------ #
# check on limit
control <- classo.control()
if (thresh >= control$epsnr){
warning("thresh should be smaller than glmnet.control()$epsnr",
call. = FALSE)
}
# ------------------------------------------------ #
# get null deviance and lambda max (no need!)
# note: need extra check
start_val <- get_start(x, y, weights, family, intercept)
# ------------------------------------------------ #
# work out lambda values
nlam <- as.integer(nlambda)
user_lambda <- FALSE   # did user provide their own lambda values?
if (is.null(lambda)) {
if (lambda.min.ratio >= 1) {
stop("lambda.min.ratio should be less than 1")
}
# compute lambda max: to add code here
lambda_max <- start_val$lambda_max
# compute lambda sequence
ulam <- exp(seq(log(lambda_max), log(lambda_max * lambda.min.ratio), length.out = nlam))
} else {  # user provided lambda values
user_lambda <- TRUE
if (any(lambda < 0)) {
stop("lambdas should be non-negative")
}
ulam <- as.double(rev(sort(lambda)))
nlam <- as.integer(length(lambda))
}
# ------------------------------------------------ #
# start progress bar
if (trace.it == 1) {
pb <- utils::txtProgressBar(min = 0, max = nlam, style = 3)
}
beta <- matrix(0, nrow = nvars, ncol = nlam)
dev.ratio <- rep(NA, length = nlam)
fit <- NULL
# mnl <- min(nlam, control$mnlam)
mnl <- nlam
for (k in 1:nlam) {
# get the correct lambda value to fit
if (k > 1) {
cur_lambda <- ulam[k]
} else {
# YK: why control$big is so large?
# cur_lambda <- ifelse(user_lambda, ulam[k], control$big)
cur_lambda <- ifelse(user_lambda, ulam[k], ulam[k])
}
if (trace.it == 2) {
cat("Fitting lambda index", k, ":", ulam[k], fill = TRUE)
}
# ------------------------------------------------ #
fit <- classo.fit(x, y, weights / sum(weights), cur_lambda,
family = family, intercept = intercept, thresh = thresh,
maxit = maxit,
warm = fit, from.classo.path = TRUE, save.fit = TRUE,
trace.it = trace.it)
if (trace.it == 1) {
utils::setTxtProgressBar(pb, k)
}
# ------------------------------------------------ #
# if error code non-zero, a non-fatal error must have occurred
# print warning, ignore this lambda value and return result
# for all previous lambda values
if (fit$jerr != 0) {
errmsg <- jerr.classofit(fit$jerr, maxit, k)
warning(errmsg$msg, call. = FALSE)
k <- k - 1
break
}
beta[, k] <- as.matrix(fit$beta)
# ------------------------------------------------ #
# YK: We do not use dev.ratio.
# dev.ratio[k] <- fit$dev.ratio
# # early stopping if dev.ratio almost 1 or no improvement
# if (k >= mnl && user_lambda == FALSE) {
#   if (dev.ratio[k] > control$devmax) {
#     break
#   }
#   else if (k > 1) {
#     if (dev.ratio[k] - dev.ratio[k-1] < control$fdev * dev.ratio[k]){
#       break
#     }
#   }
# }
}
if (trace.it == 1) {
utils::setTxtProgressBar(pb, nlam)
cat("", fill = TRUE)
}
# ------------------------------------------------ #
# truncate beta, dev.ratio, lambda if necessary
if (k < nlam) {
beta <- beta[, 1:k, drop = FALSE]
dev.ratio <- dev.ratio[1:k]
ulam <- ulam[1:k]
}
# ------------------------------------------------ #
# output
stepnames <- paste0("s", 0:(length(ulam) - 1))
dimnames(beta) <- list(vnames, stepnames)
out <- list()
out$beta <- beta
out$df <- colSums(abs(beta) > 0)
out$dim <- dim(beta)
out$lambda <- ulam
out$npasses <- fit$npasses
out$jerr <- fit$jerr
out$call <- this.call
out$nobs <- nobs
class(out) <- c("classofit", "classo")
if (trace.it) {
cat(sprintf("Fold: %d/%d\n", i, nfolds))
}
which = foldid == i
if (length(dim(y))>1){
y_sub <- y[!which, ]
} else {
y_sub = y[!which]
}
x_sub <- x[!which, , drop = FALSE]
outlist[[i]] <- classo(x, y,family=gaussian(),
weights=weights,
nlambda=100,
lambda.min.ratio=ifelse(nobs<nvars,1e-2,1e-4),
lambda = lambda,
standardized=FALSE,
intercept=FALSE,
maxit=100000,
trace.it=0)
n = 100
p = 20
x = array(rnorm(n*p), c(n,p)) + (1+1i) * array(rnorm(n*p), c(n,p))
for (j in 1:p) x[,j] = x[,j] / sqrt(mean(Mod(x[,j])^2))
e = rnorm(n) + (1+1i) * rnorm(n)
b = c(1, -1, rep(0, p-2)) + (1+1i) * c(-0.5, 2, rep(0, p-2))
y = x %*% b + e
# ------------------------------------------------ #
if (trace.it) {
cat("Training\n")
}
classo.object <- classo(x, y, weights=weights,
family=gaussian(),
nlambda=100,
lambda.min.ratio=ifelse(nobs<nvars,1e-2,1e-4),
lambda=NULL,
standardized=FALSE,
intercept=FALSE,
maxit=100000,
trace.it=0)
weights
weights <- rep(1,100)
# ------------------------------------------------ #
if (trace.it) {
cat("Training\n")
}
classo.object <- classo(x, y, weights=weights,
family=gaussian(),
nlambda=100,
lambda.min.ratio=ifelse(nobs<nvars,1e-2,1e-4),
lambda=NULL,
standardized=FALSE,
intercept=FALSE,
maxit=100000,
trace.it=0)
classo.object$call <- classo.call
subclass <- class(classo.object)[[1]]
# ------------------------------------------------ #
# cvtype.R
type.measure <- cvtype(type.measure,subclass)
outlist <- as.list(seq(nfolds))
lambda <- classo.object$lambda
i=1
if (trace.it) {
cat(sprintf("Fold: %d/%d\n", i, nfolds))
}
which = foldid == i
if (length(dim(y))>1){
y_sub <- y[!which, ]
} else {
y_sub = y[!which]
}
x_sub <- x[!which, , drop = FALSE]
weights_sub <- weights[!which]
outlist[[i]] <- classo(x_sub, y_sub,family=gaussian(),
weights=weights_sub,
nlambda=100,
lambda.min.ratio=ifelse(nobs<nvars,1e-2,1e-4),
lambda = lambda,
standardized=FALSE,
intercept=FALSE,
maxit=100000,
trace.it=0)
i=2
if (trace.it) {
cat(sprintf("Fold: %d/%d\n", i, nfolds))
}
which = foldid == i
if (length(dim(y))>1){
y_sub <- y[!which, ]
} else {
y_sub = y[!which]
}
x_sub <- x[!which, , drop = FALSE]
weights_sub <- weights[!which]
outlist[[i]] <- classo(x_sub, y_sub,family=gaussian(),
weights=weights_sub,
nlambda=100,
lambda.min.ratio=ifelse(nobs<nvars,1e-2,1e-4),
lambda = lambda,
standardized=FALSE,
intercept=FALSE,
maxit=100000,
trace.it=0)
outlist <- as.list(seq(nfolds))
lambda <- classo.object$lambda
for (i in seq(nfolds)) {
if (trace.it) {
cat(sprintf("Fold: %d/%d\n", i, nfolds))
}
which = foldid == i
if (length(dim(y))>1){
y_sub <- y[!which, ]
} else {
y_sub = y[!which]
}
x_sub <- x[!which, , drop = FALSE]
weights_sub <- weights[!which]
outlist[[i]] <- classo(x_sub, y_sub,family=gaussian(),
weights=weights_sub,
nlambda=100,
lambda.min.ratio=ifelse(nobs<nvars,1e-2,1e-4),
lambda = lambda,
standardized=FALSE,
intercept=FALSE,
maxit=100000,
trace.it=0)
}
# ------------------------------------------------ #
# buildPredmat.default.R
class(outlist) <- paste0(subclass,"list")
predmat <- buildPredmat(outlist,lambda,x,foldid,alignment)
#' @export
buildPredmat.default <- function(outlist, lambda, x, foldid, alignment){
predmat <- matrix(NA, nrow(x), length(lambda))
nfolds <- max(foldid)
nlams <- double(nfolds)
nlambda <- length(lambda)
for (i in seq(nfolds)) {
which = foldid == i
fitobj <- outlist[[i]]
# preds <- switch(alignment,
#                 lambda=predict(fitobj, x[which, , drop = FALSE], s=lambda,,...),
#                 fraction=predict(fitobj, x[which, , drop = FALSE],...) )
preds <- x[which, , drop = FALSE] %*% fitobj$beta
nlami <- min(ncol(preds),nlambda)
predmat[which, seq(nlami)] <- preds[,seq(nlami)]
if(nlami<nlambda){
predmat[which,seq(from=nlami,to=nlambda)] <- preds[,nlami]
}
}
rn <- rownames(x)
sn <- paste("s",seq(0,length=nlambda),sep="")
dimnames(predmat) <- list(rn,sn)
predmat
}
#' @export
buildPredmat <- function(outlist, lambda, x, foldid, alignment){
UseMethod("buildPredmat")
}
cv.classofit <-function(predmat,y,type.measure,weights,foldid){
family <- attr(predmat,"family")
# mumat <- family$linkinv(predmat)
nobs <- nrow(predmat)# was nrow(mumat), which failed for tweedie instance
## initialize from family function. Makes y a vector in case of binomial, and possibly changes weights
## Expects nobs to be defined, and creates n and mustart (neither used here)
## Some cases expect to see things, so we set it up just to make it work
etastart <- 0
mustart <- NULL
start <- NULL
eval(family$initialize)
##
## Just in case this was not done in initialize()
y <- drop(y)  # we don't like matrix responses
N <- nobs - apply(is.na(predmat), 2, sum)
cvraw <- switch(type.measure,
mse = abs(y - predmat))
list(cvraw=cvraw,weights=weights,N=N,type.measure=type.measure)
}
cvstats <- function(cvstuff,foldid,nfolds,lambda){
cvm <- with(cvstuff,apply(cvraw, 2, weighted.mean, w = weights, na.rm = TRUE))
cvsd <- with(cvstuff, sqrt(apply(scale(cvraw, cvm, FALSE)^2, 2, weighted.mean,
w = weights, na.rm = TRUE)/(N - 1)))
nas <- is.na(cvsd)
if(any(nas)){
lambda <- lambda[!nas]
cvm <- cvm[!nas]
cvsd <- cvsd[!nas]
}
list(lambda = lambda, cvm = cvm, cvsd = cvsd, cvup = cvm + cvsd, cvlo = cvm - cvsd)
}
getOptcv.classo <- function (lambda, cvm, cvsd, cvname) {
cvmin <- min(cvm, na.rm = TRUE)
idmin <- cvm <= cvmin
lambda.min <- max(lambda[idmin], na.rm = TRUE)
idmin <- match(lambda.min, lambda)
semin <- (cvm + cvsd)[idmin]
id1se <- cvm <= semin
lambda.1se <- max(lambda[id1se], na.rm = TRUE)
id1se <- match(lambda.1se, lambda)
index <- matrix(c(idmin,id1se),2,1,dimnames=list(c("min","1se"),"Lambda"))
list(lambda.min = lambda.min, lambda.1se = lambda.1se, index = index)
}
# ------------------------------------------------ #
# buildPredmat.default.R
class(outlist) <- paste0(subclass,"list")
predmat <- buildPredmat(outlist,lambda,x,foldid,alignment)
# ------------------------------------------------ #
### Next we compute the measures
#    if(subclass=="glmnetfit") attr(predmat,"family")=glmnet.object$family
fun <- paste("cv", subclass, sep = ".")
cvstuff <- do.call(fun, list(predmat,y,type.measure,weights,foldid))
# ------------------------------------------------ #
# cvstats.R
out <- cvstats(cvstuff,foldid,nfolds,lambda)
cvname <- names(cvstuff$type.measure)
names(cvname) <- cvstuff$type.measure
out <- c(out,list(call=cv.call,name = cvname, classo.fit = classo.object))
if (keep){
out <- c(out, list(fit.preval = predmat, foldid = foldid))
}
# ------------------------------------------------ #
# getOptcv.classo.R
lamin <- with(out,getOptcv.classo(lambda, cvm, cvsd, cvname))
obj <- c(out, as.list(lamin))
class(obj) <- "cv.classo"
obj
cv_result <- obj
save.image("D:/High-dimensional time series/SSPM/cglasso/R/test_data.RData")
# cvobj <- cv_result
cvobj <- x
xlab <- expression(Log(lambda))
#  xlab="log(Lambda)"
if(sign.lambda<0){
xlab <- paste("-",xlab,sep="")
}
sign.lambda=1
#' g2=sample(1:2,100,replace=TRUE)
#' g4=sample(1:4,100,replace=TRUE)
#' fit1=glmnet(x,y)
#' plot(fit1)
#' plot(fit1,xvar="lambda",label=TRUE)
#' fit3=glmnet(x,g4,family="multinomial")
#' plot(fit3,pch=19)
#'
#' @method plot classo
#' @export
plot.glmnet <- function(x, xvar=c("norm","lambda","dev"),label=FALSE,...){
error.bars <- function(x, upper, lower, width = 0.02, ...) {
xlim <- range(x)
barw <- diff(xlim) * width
segments(x, upper, x, lower, ...)
segments(x - barw, upper, x + barw, upper, ...)
segments(x - barw, lower, x + barw, lower, ...)
range(upper, lower)
}
# cvobj <- cv_result
cvobj <- x
xlab <- expression(Log(lambda))
#  xlab="log(Lambda)"
if(sign.lambda<0){
xlab <- paste("-",xlab,sep="")
}
plot.args <- list(x=sign.lambda*log(cvobj$lambda),
y=cvobj$cvm,ylim=range(cvobj$cvup,cvobj$cvlo),xlab=xlab,ylab=cvobj$name,type="n")
# new.args <- list(...)
# if(length(new.args)){
#   plot.args[names(new.args)]<-new.args
# }
# ------------------------------------------------ #
do.call("plot",plot.args)
error.bars(sign.lambda*log(cvobj$lambda),cvobj$cvup,cvobj$cvlo,width=0.01,
col="darkgrey")
points(sign.lambda*log(cvobj$lambda),cvobj$cvm,pch=20,col="red")
# axis(side=3,at=sign.lambda*log(cvobj$lambda),labels=paste(cvobj$nz),tick=FALSE,line=0)
abline(v=sign.lambda*log(cvobj$lambda.min),lty=3)
abline(v=sign.lambda*log(cvobj$lambda.1se),lty=3)
invisible()
cvobj <- cv_result
xlab <- expression(Log(lambda))
#  xlab="log(Lambda)"
if(sign.lambda<0){
xlab <- paste("-",xlab,sep="")
}
plot.args <- list(x=sign.lambda*log(cvobj$lambda),
y=cvobj$cvm,ylim=range(cvobj$cvup,cvobj$cvlo),xlab=xlab,ylab=cvobj$name,type="n")
# new.args <- list(...)
# if(length(new.args)){
#   plot.args[names(new.args)]<-new.args
# }
# ------------------------------------------------ #
do.call("plot",plot.args)
error.bars(sign.lambda*log(cvobj$lambda),cvobj$cvup,cvobj$cvlo,width=0.01,
col="darkgrey")
error.bars <- function(x, upper, lower, width = 0.02, ...) {
xlim <- range(x)
barw <- diff(xlim) * width
segments(x, upper, x, lower, ...)
segments(x - barw, upper, x + barw, upper, ...)
segments(x - barw, lower, x + barw, lower, ...)
range(upper, lower)
}
xlab <- expression(Log(lambda))
#  xlab="log(Lambda)"
if(sign.lambda<0){
xlab <- paste("-",xlab,sep="")
}
plot.args <- list(x=sign.lambda*log(cvobj$lambda),
y=cvobj$cvm,ylim=range(cvobj$cvup,cvobj$cvlo),xlab=xlab,ylab=cvobj$name,type="n")
# new.args <- list(...)
# if(length(new.args)){
#   plot.args[names(new.args)]<-new.args
# }
# ------------------------------------------------ #
do.call("plot",plot.args)
error.bars(sign.lambda*log(cvobj$lambda),cvobj$cvup,cvobj$cvlo,width=0.01,
col="darkgrey")
points(sign.lambda*log(cvobj$lambda),cvobj$cvm,pch=20,col="red")
# axis(side=3,at=sign.lambda*log(cvobj$lambda),labels=paste(cvobj$nz),tick=FALSE,line=0)
abline(v=sign.lambda*log(cvobj$lambda.min),lty=3)
abline(v=sign.lambda*log(cvobj$lambda.1se),lty=3)
invisible()
save.image("D:/High-dimensional time series/SSPM/cglasso/R/test_data.RData")
library(devtools)
library(roxygen2)
roxygenise()
roxygenise
package.skeleton("cglasso")
getwd()
setwd("D:/High-dimensional time series/SSPM/cglasso")
roxygenize
roxygenize()
roxygenize()
devtools::create("cglasso")
getwd()
setwd("D:/High-dimensional time series/SSPM")
devtools::create("cglasso")
getwd()
setwd("D:/High-dimensional time series/SSPM/cglasso")
roxygenize()
roxygenize()
roxygenize()
roxygenize()
roxygenize()
as.package("cglasso")
my.package <- as.package("cglasso")
library(cglasso)
classo
dyn.load("D:/High-dimensional time series/SSPM/cglasso/src/classocd_warm.dll")
n = 1000
p = 200
x = array(rnorm(n*p), c(n,p)) + (1+1i) * array(rnorm(n*p), c(n,p))
for (j in 1:p) x[,j] = x[,j] / sqrt(mean(Mod(x[,j])^2))
e = rnorm(n) + (1+1i) * rnorm(n)
b = c(1, -1, rep(0, p-2)) + (1+1i) * c(-0.5, 2, rep(0, p-2))
y = x %*% b + e
fit.test = classo(x, y)
