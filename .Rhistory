coef(fit, s = 0.1)
set.seed(29)
nx <- array(rnorm(5*20), c(5,20)) + (1+1i) * array(rnorm(5*20), c(5,20))
for (j in 1:20) nx[,j] <- nx[,j] / sqrt(mean(Mod(nx[,j])^2))
predict(fit, newx = nx, s = c(0.1, 0.05))
cvfit <- cv.classo(x, y)
plot(cvfit)
cvfit$lambda.min
coef(cvfit, s = "lambda.min")
predict(cvfit, newx = x[1:5,], s = "lambda.min")
set.seed(29)
nx <- array(rnorm(5*20), c(5,20)) + (1+1i) * array(rnorm(5*20), c(5,20))
for (j in 1:20) nx[,j] <- nx[,j] / sqrt(mean(Mod(nx[,j])^2))
predict(fit, newx = nx, s = c(0.1, 0.05))
set.seed(29)
nx <- array(rnorm(5*20), c(5,20)) + (1+1i) * array(rnorm(5*20), c(5,20))
for (j in 1:20) nx[,j] <- nx[,j] / sqrt(mean(Mod(nx[,j])^2))
predict(fit, newx = nx, s = 0.1)
lambda.interp=function(lambda,s){
### lambda is the index sequence that is produced by the model
### s is the new vector at which evaluations are required.
### the value is a vector of left and right indices, and a vector of fractions.
### the new values are interpolated bewteen the two using the fraction
### Note: lambda decreases. you take:
### sfrac*left+(1-sfrac*right)
if(length(lambda)==1){# degenerate case of only one lambda
nums <- length(s)
left <- rep(1,nums)
right <- left
sfrac <- rep(1,nums)
}
else{
## s[s > max(lambda)] = max(lambda)
## s[s < min(lambda)] = min(lambda)
k <- length(lambda)
sfrac <- (lambda[1]-s)/(lambda[1] - lambda[k])
lambda <- (lambda[1] - lambda)/(lambda[1] - lambda[k])
sfrac[sfrac < min(lambda)] <- min(lambda)
sfrac[sfrac > max(lambda)] <- max(lambda)
coord <- approx(lambda, seq(lambda), sfrac)$y
left <- floor(coord)
right <- ceiling(coord)
sfrac <- (sfrac-lambda[right])/(lambda[left] - lambda[right])
sfrac[left==right]=1
sfrac[abs(lambda[left]-lambda[right])<.Machine$double.eps]=1
}
list(left=left,right=right,frac=sfrac)
}
lambda.interp(fit$lambda,c(0.01,0.5))
Diagonal(x=lambda.interp(fit$lambda,c(0.01,0.5))$frac)
as.matrix(Diagonal(x=lambda.interp(fit$lambda,c(0.01,0.5))$frac))
nbeta[,lambda.interp(fit$lambda,c(0.01,0.5))$left,drop=FALSE]
nbeta <- fit$beta
nbeta[,lambda.interp(fit$lambda,c(0.01,0.5))$left,drop=FALSE]
nbeta[,lambda.interp(fit$lambda,c(0.01,0.5))$left,drop=FALSE] %*% as.matrix(Diagonal(x=lambda.interp(fit$lambda,c(0.01,0.5))$frac))
class(nx)
dim(nx)
nx
dim(nx)
predict(fit, newx = nx, s = c(0.1, 0.05))
fit$lambda
predict(fit, newx = nx)
class(Diagonal(x=lambda.interp(fit$lambda,c(0.01,0.5))$frac))
lambda.interp(fit$lambda,c(0.01,0.5))$frac
diag(lambda.interp(fit$lambda,c(0.01,0.5))$frac)
lambda.interp(fit$lambda,c(0.01,0.5))$frac
diag(lambda.interp(fit$lambda,c(0.01,0.5))$frac[1])
diag(lambda.interp(fit$lambda,c(0.01,0.5))$frac[1,])
diag(lambda.interp(fit$lambda,c(0.01,0.5))$frac[1],1)
x=lamlist$frac
diag(1,1)
diag(c(2,1),2)
diag(lamlist$frac,length(lamlist$frac))
devtools::load_all(".")
document()
library(cglasso)
data(QuickStartExample)
x <- QuickStartExample$x
y <- QuickStartExample$y
fit <- classo(x, y)
plot(fit)
coef(fit, s = 0.1)
set.seed(29)
nx <- array(rnorm(5*20), c(5,20)) + (1+1i) * array(rnorm(5*20), c(5,20))
for (j in 1:20) nx[,j] <- nx[,j] / sqrt(mean(Mod(nx[,j])^2))
predict(fit, newx = nx, s = c(0.1, 0.05))
?print.cglasso
cglasso::print.cglasso
?cglasso::print.cglasso
?cglasso::print.classo
print.classo
predict.classo
predict(fit, newx = nx)
as.matrix(cbind2(1,newx)%*%nbeta)
devtools::load_all(".")
document()
library(cglasso)
data(QuickStartExample)
x <- QuickStartExample$x
y <- QuickStartExample$y
fit <- classo(x, y)
plot(fit)
coef(fit, s = 0.1)
set.seed(29)
nx <- array(rnorm(5*20), c(5,20)) + (1+1i) * array(rnorm(5*20), c(5,20))
for (j in 1:20) nx[,j] <- nx[,j] / sqrt(mean(Mod(nx[,j])^2))
predict(fit, newx = nx, s = c(0.1, 0.05))
?glmnet
library(glmnet)
x = matrix(rnorm(100 * 20), 100, 20)
y = rnorm(100)
fit1 = glmnet(x, y)
fit1$offset
predict(fit1, newx = x[1:10, ], s = c(0.01, 0.005))
devtools::load_all(".")
document()
library(cglasso)
data(QuickStartExample)
x <- QuickStartExample$x
y <- QuickStartExample$y
fit <- classo(x, y)
plot(fit)
coef(fit, s = 0.1)
set.seed(29)
nx <- array(rnorm(5*20), c(5,20)) + (1+1i) * array(rnorm(5*20), c(5,20))
for (j in 1:20) nx[,j] <- nx[,j] / sqrt(mean(Mod(nx[,j])^2))
predict(fit, newx = nx, s = c(0.1, 0.05))
cvfit <- cv.classo(x, y)
plot(cvfit)
cvfit$lambda.min
coef(cvfit, s = "lambda.min")
predict(cvfit, newx = x[1:5,], s = "lambda.min")
?predict
predict(cvfit, newx = x[1:5,])
class(cvfit)
class(fit)
library(glmnet)
x = matrix(rnorm(100 * 20), 100, 20)
y = rnorm(100)
fit1 = glmnet(x, y)
class(fit1)
?cv.glmnet
set.seed(1010)
n = 1000
p = 100
nzc = trunc(p/10)
x = matrix(rnorm(n * p), n, p)
beta = rnorm(nzc)
fx = x[, seq(nzc)] %*% beta
eps = rnorm(n) * 5
y = drop(fx + eps)
cvob1 = cv.glmnet(x, y)
class(cvob1)
devtools::load_all(".")
document()
library(cglasso)
data(QuickStartExample)
x <- QuickStartExample$x
y <- QuickStartExample$y
fit <- classo(x, y)
plot(fit)
coef(fit, s = 0.1)
set.seed(29)
nx <- array(rnorm(5*20), c(5,20)) + (1+1i) * array(rnorm(5*20), c(5,20))
for (j in 1:20) nx[,j] <- nx[,j] / sqrt(mean(Mod(nx[,j])^2))
predict(fit, newx = nx, s = c(0.1, 0.05))
cvfit <- cv.classo(x, y)
plot(cvfit)
cvfit$lambda.min
coef(cvfit, s = "lambda.min")
predict(cvfit, newx = x[1:5,], s = "lambda.min")
?predict.cv.classo
?predict.cv.classo()
predict.cv.classo()
predict(cvfit, newx = x[1:5,])
cvfit$classo.fit
set.seed(1010)
n = 1000
p = 100
nzc = trunc(p/10)
x = matrix(rnorm(n * p), n, p)
beta = rnorm(nzc)
fx = x[, seq(nzc)] %*% beta
eps = rnorm(n) * 5
y = drop(fx + eps)
cvob1 = cv.glmnet(x, y)
cvob1$glmnet.fit
x = matrix(rnorm(100 * 20), 100, 20)
y = rnorm(100)
fit1 = glmnet(x, y)
fit1$dev.ratio
s=c("lambda.1se","lambda.min")
match.arg(s)
match.arg("lambda.min")
s=match.arg(s)
s=match.arg("lambda.min")
match.arg("lambda.min",c("lambda.1se","lambda.min"))
cvob1[["lambda.min"]]
cvob1$lambda.min
cvob1$lambda
cvob1$lambda == cvob1$lambda.min
cvob1$glmnet.fit$beta
dim(cvob1$glmnet.fit$beta)
which(cvob1$lambda == cvob1$lambda.min)
cvob1$glmnet.fit$beta[,which(cvob1$lambda == cvob1$lambda.min)]
class(fit1)
dim(fit1$beta)
cvfit$classo.fit$beta
dim(cvfit$classo.fit$beta)
cvfit$classo.fit
class(fit)
class(object$classo.fit)
class(cvfit$classo.fit)
predict(cvfit$classo.fit,nx,s=1)
?predict.cv.classo
predict.cv.classo
#' make predictions from a "cv.classo" object.
#'
#' This function makes predictions from a cross-validated classo model, using
#' the stored \code{"classo.fit"} object.
#'
#' This function makes it easier to use the results of cross-validation to make
#' a prediction.
#'
#' @aliases coef.cv.classo predict.cv.classo
#' @param object Fitted \code{"cv.classo"} object.
#' @param newx Matrix of new values for \code{x} at which predictions are to be
#' made. Must be a matrix
#' @param s Value(s) of the penalty parameter \code{lambda} at which
#' predictions are required. Default is the value \code{s="lambda.1se"} stored
#' on the CV \code{object}. Alternatively \code{s="lambda.min"} can be used. If
#' \code{s} is numeric, it is taken as the value(s) of \code{lambda} to be
#' used. (For historical reasons we use the symbol 's' rather than 'lambda' to
#' reference this parameter)
#' @param \dots Not used. Other arguments to predict.
#' @return The object returned depends on the \dots{} argument which is passed
#' on to the \code{predict} method for \code{classo} objects.
#' @author Younghoon Kim, Navonil Deb, Sumanta Basu \cr Maintainer:
#' Younghoon Kim <yk748@cornell.edu>
#' @seealso \code{classo}, and \code{print}, and \code{coef} methods, and
#' \code{cv.classo}.
#' @keywords models regression
#'
#' @method predict cv.classo
#' @export
predict.cv.classo <- function(object,newx,s=c("lambda.1se","lambda.min"),...){
if(is.numeric(s)){
lambda <- s
}
else
if(is.character(s)){
s <- match.arg(s)
lambda <- object[[s]]
names(lambda) <- s
}
else {
stop("Invalid form for s")
}
predict(object$classo.fit,newx,s=lambda,...)
}
predict(cvfit, newx = x[1:5,], s = "lambda.min")
fit <- classo(x, y)
library(cglasso)
data(QuickStartExample)
x <- QuickStartExample$x
y <- QuickStartExample$y
fit <- classo(x, y)
coef(fit, s = 0.1)
set.seed(29)
nx <- array(rnorm(5*20), c(5,20)) + (1+1i) * array(rnorm(5*20), c(5,20))
for (j in 1:20) nx[,j] <- nx[,j] / sqrt(mean(Mod(nx[,j])^2))
predict(fit, newx = nx, s = c(0.1, 0.05))
cvfit <- cv.classo(x, y)
plot(cvfit)
cvfit$lambda.min
coef(cvfit, s = "lambda.min")
predict(cvfit, newx = x[1:5,], s = "lambda.min")
devtools::load_all(".")
document()
library(cglasso)
data(QuickStartExample)
x <- QuickStartExample$x
y <- QuickStartExample$y
fit <- classo(x, y)
plot(fit)
coef(fit, s = 0.1)
set.seed(29)
nx <- array(rnorm(5*20), c(5,20)) + (1+1i) * array(rnorm(5*20), c(5,20))
for (j in 1:20) nx[,j] <- nx[,j] / sqrt(mean(Mod(nx[,j])^2))
predict(fit, newx = nx, s = c(0.1, 0.05))
cvfit <- cv.classo(x, y)
plot(cvfit)
cvfit$lambda.min
coef(cvfit, s = "lambda.min")
predict(cvfit, newx = x[1:5,], s = "lambda.min")
library(devtools)
library(roxygen2)
devtools::load_all(".")
library(devtools)
library(roxygen2)
getwd()
package.skeleton(name="cxreg")
setwd("D:/High-dimensional time series/SSPM")
package.skeleton(name="cxreg")
load_all("cxreg")
document()
use_description(fields = list(
Title = "cxreg",
Version = "0.1.0",
Authors@R = c(
use_description(fields = list(
Title = "cxreg",
Version = "0.1.0",
Authors@R =
use_description(fields = list(
Title = "cxreg",
Version = "0.1.0",
Authors@R = person("Younghoon", "Kim", , "yk748@cornell.edu", role = c("aut", "cre")),
use_description(fields = list(
Title = "cxreg",
Version = "0.1.0",
Authors@R = utils::person("Younghoon", "Kim", , "yk748@cornell.edu", role = c("aut", "cre"),
use_description(fields = list(
Title = "cxreg",
Version = "0.1.0",
Authors@R = utils::person("Younghoon", "Kim", "yk748@cornell.edu", role = c("aut", "cre"),
use_description(fields = list(
Title = "cxreg",
Version = "0.1.0",
Authors@R = utils::person("Younghoon", "Kim", email="yk748@cornell.edu", role = c("aut", "cre"),
use_description(fields = list(
Title = "cxreg",
Version = "0.1.0",
Authors@R = utils::person("Younghoon", "Kim", email = "yk748@cornell.edu", role = c("aut", "cre"),
use_description(fields = list(
Title = "cxreg",
Version = "0.1.0",
Authors@R = person("Younghoon", "Kim", email = "yk748@cornell.edu", role = c("aut", "cre"),
use_description(fields = list(
Title = "cxreg",
Version = "0.1.0",
Authors@R = person("Younghoon", "Kim", email = "yk748@cornell.edu", role = c("aut", "cre"),
use_description(fields = list(
Title = "cxreg",
Version = "0.1.0",
Authors@R = c(person("Younghoon", "Kim", email = "yk748@cornell.edu", role = c("aut", "cre"),
use_description(fields = list(
Title = "cxreg",
Version = "0.1.0",
"Authors@R" = person("Younghoon", "Kim", email = "yk748@cornell.edu", role = c("aut", "cre"),
comment = c(ORCID = "0009-0007-0117-5530")),
Description = "This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
License = "MIT + file LICENSE"
))
use_description(fields = list(
Title = "cxreg",
Version = "0.1.0",
"Authors@R" = person("Younghoon", "Kim", email = "yk748@cornell.edu", role = c("aut", "cre"),
comment = c(ORCID = "0009-0007-0117-5530")),
Description = "This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
License = "MIT + file LICENSE"
))
getwd()
setwd("D:/High-dimensional time series/SSPM/cxreg")
use_description(fields = list(
Title = "cxreg",
Version = "0.1.0",
"Authors@R" = person("Younghoon", "Kim", email = "yk748@cornell.edu", role = c("aut", "cre"),
comment = c(ORCID = "0009-0007-0117-5530")),
Description = "This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
License = "MIT + file LICENSE"
))
use_description(fields = list(
Title = "cxreg",
Version = "0.1.0",
"Authors@R" = c(person("Younghoon", "Kim", email = "yk748@cornell.edu", role = c("aut", "cre"),
comment = c(ORCID = "0009-0007-0117-5530")),
person("Navonil", "Deb", role = c("aut")),
person("Sumanta", "Basu", role = c("aut"))),
Description = "This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
License = "MIT + file LICENSE"
))
load_all("cxreg")
document()
getwd()
setwd("D:/High-dimensional time series/SSPM")
load_all("cxreg")
load_all("cxreg")
library(devtools)
library(roxygen2)
load_all("cxreg")
package.skeleton("cxreg")
getwd()
setwd("D:/High-dimensional time series/SSPM")
package.skeleton("cxreg")
load_all("cxreg")
document()
document()
roxygen2::roxygenise()
setwd("D:/High-dimensional time series/SSPM/cxreg")
roxygen2::roxygenise()
library(roxygen2)
roxygen2::roxygenise()
library(devtools)
devtools::document()
package.skeleton("cxreg")
rm(list = ls())
character(0)
package.skeleton(name="cxreg")
setwd("D:/High-dimensional time series/SSPM/cxreg/R")
package.skeleton(name="cxreg")
setwd("D:/High-dimensional time series/SSPM")
devtools::load_all("cxreg")
useDynLib(cxreg)
library(devtools)
library(roxygen2)
useDynLib(cxreg)
devtools::install_github("helske/changer")
library(changer)
changer("D:/High-dimensional time series/SSPM", "cxreg")
library(changer)
changer("D:/High-dimensional time series/SSPM/cxreg", "cxreg")
remove.packages("cglasso")
package.skeleton(name="cxreg")
use_description(fields = list(package="cxreg"))
getwd()
setwd("D:/High-dimensional time series/SSPM/cxreg")
use_description(fields = list(package="cxreg"))
use_description(fields = list(Package="cxreg"))
use_description(fields = list(Package="cxreg",
Title="complex-valued penalized regression (Lasso)",
"Authors@R" = c(person("Younghoon","Kim",email="yk748@cornell.edu",role=c("aut","cre"),comment=c(ORCID="0009-0007-0117-5530")),
person("Navonil","Deb",role=c("cre")),
person("Sumanta","Basu",role=c("cre"))),
Description="This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
License = "MIT + file LICENSE"))
devtools::load_all("cxreg")
roxygen2::roxygenise()
devtools::load_all(".")
devtools::load_all(".")
use_description(fields = list(Package="cxreg",
Title="complex-valued penalized regression (Lasso)",
Version="0.1.0",
"Authors@R" = c(person("Younghoon","Kim",email="yk748@cornell.edu",role=c("aut","cre"),comment=c(ORCID="0009-0007-0117-5530")),
person("Navonil","Deb",role=c("cre")),
person("Sumanta","Basu",role=c("cre"))),
Description="This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
License = "MIT + file LICENSE"))
roxygen2::roxygenise()
find_rtools()
pkgbuild::compile_dll()
devtools::document()
roxygen2::roxygenise()
use_description(fields = list(Package="cxreg",
Title="complex-valued penalized regression (Lasso)",
Version="0.1.0",
"Authors@R" = c(person("Younghoon","Kim",email="yk748@cornell.edu",role=c("aut","cre"),comment=c(ORCID="0009-0007-0117-5530")),
person("Navonil","Deb",role=c("cre")),
person("Sumanta","Basu",role=c("cre"))),
Description="This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
License = "MIT + file LICENSE"))
devtools::load_all(".")
library(devtools)
library(roxygen2)
devtools::load_all(".")
use_description(fields = list(Package="cxreg",
Title="complex-valued penalized regression (Lasso)",
Version="0.1.0",
"Authors@R" = c(person("Younghoon","Kim",email="yk748@cornell.edu",role=c("aut","cre"),comment=c(ORCID="0009-0007-0117-5530")),
person("Navonil","Deb",role=c("cre")),
person("Sumanta","Basu",role=c("cre"))),
Description="This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
License = "MIT + file LICENSE",
Maintainer = 'Younghoon Kim <yk748@cornell.edu>'))
devtools::load_all(".")
use_description(fields = list(Package="cxreg",
Title="complex-valued penalized regression (Lasso)",
Version="0.1.0",
"Authors@R" = c(person("Younghoon","Kim",email="yk748@cornell.edu",role=c("aut","cre"),comment=c(ORCID="0009-0007-0117-5530")),
person("Navonil","Deb",role=c("aut")),
person("Sumanta","Basu",role=c("aut"))),
Description="This package contains glmnet-style complex-valued lasso formulation via complex update coordinate descent algorithm and its supporting functions. Codes for solving complex graphical Lasso and computing entrywise confidence interval will be added soon.",
License = "MIT + file LICENSE",
Maintainer = 'Younghoon Kim <yk748@cornell.edu>'))
devtools::load_all(".")
exportPattern(".*")
document()
devtools::document()
use_namespace(roxygen = TRUE)
getwd()
devtools::load_all(".")
package.skeleton(name="cxreg")
package.skeleton(name="cxreg")
getwd()
setwd("D:/High-dimensional time series/SSPM")
package.skeleton(name="cxreg2")
devtools::document()
setwd("D:/High-dimensional time series/SSPM/cxreg")
devtools::document()
.Last.error
setwd("D:/High-dimensional time series/SSPM/cxreg/R")
devtools::document()
install.package(devtools)
install.packages(devtools)
install.packages("devtools")
install.packages("devtools")
library(devtools)
devtools::document()
devtools::load_all("D:/High-dimensional time series/SSPM/cxreg")
devtools::document()
devtools::document()
devtools::load_all(".")
